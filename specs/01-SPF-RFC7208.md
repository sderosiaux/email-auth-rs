# SPF Implementation Spec (RFC 7208)

> LLM-actionable specification for implementing Sender Policy Framework

## Overview

SPF allows domain owners to publish DNS TXT records declaring which mail servers are authorized to send email on their behalf. Receiving servers query these records and evaluate sender IP against the policy.

---

## 1. Data Types

### 1.1 SPF Record Structure

- [ ] Define `SpfRecord` struct containing:
  - [ ] `directives: Vec<Directive>` (mechanisms with qualifiers, in order)
  - [ ] `redirect: Option<String>` (redirect modifier target domain)
  - [ ] `explanation: Option<String>` (exp= modifier domain)
  - [ ] Unknown modifiers: silently ignored (forward compatibility per RFC 7208 §6)

### 1.2 Directive (Mechanism + Qualifier)

- [ ] Define `Directive` struct:
  - [ ] `qualifier: Qualifier` (enum: Pass `+`, Fail `-`, SoftFail `~`, Neutral `?`)
  - [ ] `mechanism: Mechanism`

### 1.3 Mechanisms

- [ ] Define `Mechanism` enum with variants:
  - [ ] `All` — matches everything
  - [ ] `Include { domain: String }` — recursive lookup
  - [ ] `A { domain: Option<String>, cidr4: Option<u8>, cidr6: Option<u8> }` — A/AAAA records
  - [ ] `Mx { domain: Option<String>, cidr4: Option<u8>, cidr6: Option<u8> }` — MX records
  - [ ] `Ptr { domain: Option<String> }` — PTR record (deprecated but MUST support per RFC)
  - [ ] `Ip4 { addr: Ipv4Addr, prefix: Option<u8> }` — IPv4 CIDR
  - [ ] `Ip6 { addr: Ipv6Addr, prefix: Option<u8> }` — IPv6 CIDR
  - [ ] `Exists { domain: String }` — DNS existence check

### 1.4 Dual CIDR

- [ ] A and Mx mechanisms support dual CIDR: `a:domain/cidr4//cidr6`
  - [ ] Parse both prefixes independently
  - [ ] Default cidr4=32, cidr6=128
  - [ ] Validate prefix ranges: v4 0-32, v6 0-128

### 1.5 Result Types

- [ ] Define `SpfResult` enum (RFC 7208 Section 2.6):
  - [ ] `Pass` — sender is authorized
  - [ ] `Fail { explanation: Option<String> }` — sender is NOT authorized, with optional explanation from exp=
  - [ ] `SoftFail` — weak authorization failure
  - [ ] `Neutral` — no assertion made
  - [ ] `None` — no SPF record found
  - [ ] `TempError` — transient DNS error
  - [ ] `PermError` — permanent error (syntax, too many lookups, etc.)

### 1.6 Macro Context

- [ ] Define `MacroContext` struct for macro expansion:
  - [ ] `sender: String` — full sender address (local-part@domain)
  - [ ] `local_part: String` — local-part of sender
  - [ ] `sender_domain: String` — domain of sender
  - [ ] `client_ip: IpAddr` — connecting server IP
  - [ ] `helo: String` — HELO/EHLO identity
  - [ ] `domain: String` — current domain being evaluated
  - [ ] `receiver: String` — receiving domain name (for `%{r}` macro)

---

## 2. Record Parsing (RFC 7208 Section 12)

### 2.1 TXT Record Retrieval

- [ ] Query DNS TXT records for domain
- [ ] Filter records starting with "v=spf1" followed by space or end-of-string (case-insensitive)
- [ ] Handle multiple TXT records: MUST be exactly one SPF record, else `PermError`
- [ ] Handle no SPF record: return `None`
- [ ] DNS TempFail during TXT query: return `TempError`

### 2.2 Record Grammar (ABNF from RFC 7208)

- [ ] Parse version: `"v=spf1"` (case-insensitive)
- [ ] Parse directives: `[qualifier] mechanism`
- [ ] Default qualifier is `+` (Pass) if omitted
- [ ] Parse modifiers: `name=value` (only `redirect` and `exp` defined)
- [ ] Handle unknown mechanisms: `PermError` (NOT silently skip)
- [ ] Handle unknown modifiers: ignore (forward compatibility)
- [ ] Handle duplicate redirect or exp modifiers: `PermError`
- [ ] Whitespace between terms: one or more spaces, trimmed

### 2.3 Mechanism Argument Parsing

- [ ] `all` — no arguments
- [ ] `include:<domain>` — domain spec required
- [ ] `a` / `a:<domain>` / `a:<domain>/<cidr4>` / `a:<domain>//<cidr6>` / `a:<domain>/<cidr4>//<cidr6>`
- [ ] `mx` — same argument patterns as `a`
- [ ] `ptr` / `ptr:<domain>` — optional domain
- [ ] `ip4:<ip4-network>` — address with optional `/prefix` (default /32)
- [ ] `ip6:<ip6-network>` — address with optional `/prefix` (default /128)
- [ ] `exists:<domain>` — domain spec with macros

### 2.4 Macro Expansion (RFC 7208 Section 7)

- [ ] Implement macro expander for domain-spec strings
- [ ] Macro letters (case determines URL encoding):
  - [ ] `s` — sender (local-part@domain or postmaster@domain)
  - [ ] `l` — local-part of sender
  - [ ] `o` — domain of sender
  - [ ] `d` — current domain being evaluated
  - [ ] `i` — client IP (dotted for v4, dot-separated nibbles for v6: 32 hex chars separated by dots)
  - [ ] `p` — validated domain name of client IP (PTR). Return "unknown" if PTR validation not performed.
  - [ ] `v` — IP version string ("in-addr" for v4, "ip6" for v6)
  - [ ] `h` — HELO/EHLO domain
- [ ] Explanation-only macro letters (ONLY valid in `exp=` TXT expansion):
  - [ ] `c` — SMTP client IP in human-readable format (plain dotted-decimal/colon-hex)
  - [ ] `r` — receiving MTA domain name
  - [ ] `t` — current Unix timestamp as decimal string
- [ ] MUST reject `c`, `r`, `t` when expanding in non-exp context
- [ ] Uppercase macro letter → URL-encode the expanded value
- [ ] Delimiter transformers: `{<letter><digits>r<delimiters>}`
  - [ ] Digits: take rightmost N parts (0 means all)
  - [ ] `r`: reverse order of parts
  - [ ] Delimiters: split characters (default ".")
- [ ] Escapes: `%%` (literal %), `%_` (space), `%-` (URL-encoded space `%20`)

---

## 3. Evaluation Algorithm: `check_host()` (RFC 7208 Section 4)

### 3.1 Function Signature

```rust
pub async fn check_host<R: DnsResolver>(
    resolver: &R,
    ip: IpAddr,
    helo: &str,
    sender: &str,    // MAIL FROM address
    domain: &str,    // domain to check SPF for
    receiver: &str,  // receiver hostname for %{r} macro
) -> SpfResult
```

No builder pattern needed — 6 parameters is acceptable for a low-level function.

### 3.2 Input Handling

- [ ] Empty MAIL FROM: use `postmaster@<helo_domain>` as sender
- [ ] MAIL FROM without `@`: use `postmaster@<helo_domain>` as sender

### 3.3 DNS Lookup Limits (RFC 7208 Section 4.6.4)

- [ ] Track DNS lookup count across entire evaluation (including recursive include/redirect)
- [ ] Limit: max 10 DNS-querying mechanism lookups (A, MX, PTR, include, redirect, exists)
- [ ] `ip4`, `ip6`, `all` do NOT count toward limit
- [ ] Exceeding limit → `PermError`
- [ ] Track void lookups (NxDomain or empty response on DNS-querying mechanisms): max 2 void lookups → `PermError`
- [ ] Use shared mutable `EvalContext` struct across recursive calls:
  ```rust
  struct EvalContext {
      dns_lookups: usize,
      void_lookups: usize,
      visited_domains: HashSet<String>,  // for cycle detection
  }
  ```

### 3.4 Circular Include/Redirect Detection (RFC 7208 §4.6.4)

- [ ] Track visited domains in `EvalContext.visited_domains` (normalized: lowercase, no trailing dot)
- [ ] Before each recursive `check_host` call (include or redirect): check if domain already visited
- [ ] If visited: return `PermError` immediately
- [ ] The DNS lookup limit (10) provides a secondary safety net but is NOT sufficient alone — a 2-domain cycle with 1-mechanism SPF records would execute up to 10 iterations before stopping

### 3.5 Mechanism Evaluation Order

- [ ] Evaluate directives left-to-right
- [ ] First match determines result (qualifier → result mapping)
- [ ] If no match and no `redirect`: return `Neutral`
- [ ] If `redirect` modifier present: evaluate target domain instead

### 3.6 Individual Mechanism Evaluation

#### `all`
- [ ] Always matches
- [ ] Typically last directive (e.g., `-all`, `~all`)

#### `include:<domain>`
- [ ] Increment DNS lookup counter
- [ ] Check visited domains → `PermError` if cycle detected
- [ ] Expand macros in domain
- [ ] Recursively call `check_host()` with new domain
- [ ] Map child results:
  - [ ] `Pass` → match (use parent qualifier)
  - [ ] `Fail`, `SoftFail`, `Neutral`, `None` → no match (continue)
  - [ ] `TempError` → propagate `TempError`
  - [ ] `PermError` → propagate `PermError`

#### `a` / `a:<domain>`
- [ ] Increment DNS lookup counter
- [ ] Expand macros in domain (default: current domain)
- [ ] Query A records (if client is IPv4) or AAAA (if IPv6) — query only the address family that matches client IP
- [ ] Apply CIDR mask (default /32 for v4, /128 for v6)
- [ ] Match if client IP within any returned network
- [ ] NxDomain → void lookup, no match
- [ ] TempFail → `TempError`

#### `mx` / `mx:<domain>`
- [ ] Increment DNS lookup counter
- [ ] Expand macros in domain
- [ ] Query MX records, sort by preference
- [ ] Limit to first 10 MX records
- [ ] For each MX host: query A/AAAA, apply CIDR mask
- [ ] Match if client IP within any resolved address
- [ ] DNS errors on individual MX hosts: skip that host (not fatal)

#### `ptr` / `ptr:<domain>` (deprecated, MUST still support)
- [ ] Increment DNS lookup counter
- [ ] Reverse lookup client IP → hostnames
- [ ] Limit to 10 PTR names
- [ ] For each hostname: forward lookup → IPs
- [ ] Confirm client IP in forward results (validated hostname)
- [ ] Match if any validated hostname equals or is subdomain of target domain
- [ ] Expensive: avoid in production records, but MUST evaluate correctly

#### `ip4:<network>`
- [ ] Parse IPv4 address and optional prefix length (default /32)
- [ ] Match if client is IPv4 AND within CIDR range
- [ ] IPv6 client: never matches ip4
- [ ] No DNS lookup, no counter increment

#### `ip6:<network>`
- [ ] Parse IPv6 address and optional prefix length (default /128)
- [ ] Match if client is IPv6 AND within CIDR range
- [ ] IPv4 client: never matches ip6
- [ ] No DNS lookup, no counter increment

#### `exists:<domain>`
- [ ] Increment DNS lookup counter
- [ ] Expand macros in domain
- [ ] Query A record: any result = match, NxDomain = no match
- [ ] TempFail → `TempError`

### 3.7 Modifier Processing

#### `redirect=<domain>`
- [ ] Only processed if no directive matched
- [ ] Increment DNS lookup counter
- [ ] Check visited domains → `PermError` if cycle
- [ ] Expand macros in domain
- [ ] Empty expanded domain → `PermError`
- [ ] Recursively `check_host()` on target
- [ ] Target returns `None` → `PermError` (redirect to domain without SPF)
- [ ] All other results passed through unchanged

#### `exp=<domain>`
- [ ] Only evaluated when final result is `Fail`
- [ ] Expand macros in exp domain
- [ ] Query TXT record at expanded domain
- [ ] Expand macros in TXT result (including explanation-only macros: `c`, `r`, `t`)
- [ ] Attach expanded explanation to `Fail { explanation: Some(text) }`
- [ ] Failure to retrieve/expand explanation: silently ignore, return Fail without explanation

### 3.8 CIDR Matching Implementation

```rust
fn ip4_in_network(ip: Ipv4Addr, network: Ipv4Addr, prefix: u8) -> bool {
    if prefix == 0 { return true; }
    if prefix > 32 { return false; }
    let mask = !0u32 << (32 - prefix);
    (u32::from(ip) & mask) == (u32::from(network) & mask)
}

fn ip6_in_network(ip: Ipv6Addr, network: Ipv6Addr, prefix: u8) -> bool {
    if prefix == 0 { return true; }
    if prefix > 128 { return false; }
    let mask = !0u128 << (128 - prefix);
    (u128::from(ip) & mask) == (u128::from(network) & mask)
}
```

### 3.9 Async Recursion

- [ ] `check_host_inner` must use `Box::pin` for async recursion (include/redirect chains)
- [ ] Signature: returns `Pin<Box<dyn Future<Output = SpfResult> + Send + 'a>>`
- [ ] `EvalContext` is `&mut` — passed through the recursive chain

---

## 4. DNS Interface Requirements

- [ ] Abstract DNS resolver trait for testability (defined in M1 common module)
- [ ] Support async DNS queries
- [ ] Methods needed:
  - [ ] `query_txt(domain) -> Result<Vec<String>, DnsError>`
  - [ ] `query_a(domain) -> Result<Vec<Ipv4Addr>, DnsError>`
  - [ ] `query_aaaa(domain) -> Result<Vec<Ipv6Addr>, DnsError>`
  - [ ] `query_mx(domain) -> Result<Vec<MxRecord>, DnsError>`
  - [ ] `query_ptr(ip) -> Result<Vec<String>, DnsError>`
  - [ ] `query_exists(domain) -> Result<bool, DnsError>` (A-record existence check)
- [ ] DnsError MUST distinguish: NxDomain vs NoRecords vs TempFail
- [ ] DNS caching: CALLER responsibility (resolver layer), not library scope. Document this.

---

## 5. Error Handling

- [ ] `PermError` conditions:
  - [ ] Multiple SPF records for same domain
  - [ ] Syntax errors in record
  - [ ] Unknown mechanism (NOT unknown modifier)
  - [ ] DNS lookup limit exceeded (>10)
  - [ ] Void lookup limit exceeded (>2)
  - [ ] `redirect` to domain with no SPF
  - [ ] Circular `include`/`redirect` (detected via visited set)
  - [ ] Empty expanded domain in redirect
  - [ ] Duplicate redirect or exp modifier
- [ ] `TempError` conditions:
  - [ ] DNS timeout or SERVFAIL
  - [ ] Transient network errors

---

## 6. Test Cases

### 6.1 Parsing Tests

- [ ] Valid minimal: `v=spf1 -all`
- [ ] Multiple mechanisms: `v=spf1 ip4:192.0.2.0/24 ip4:198.51.100.0/24 -all`
- [ ] Include: `v=spf1 include:_spf.google.com -all`
- [ ] All mechanism types with all argument forms
- [ ] Macros in domain specs: `exists:%{ir}.sbl.example.com`
- [ ] Case insensitivity: `V=SPF1 IP4:...` → same as lowercase
- [ ] Invalid version: `v=spf2` → error
- [ ] Duplicate modifiers: `redirect=a redirect=b` → PermError
- [ ] Unknown modifier: `foo=bar` → silently ignored
- [ ] Unknown mechanism: `custom:example.com` → PermError
- [ ] Multiple whitespace between terms
- [ ] Trailing whitespace
- [ ] A/MX dual CIDR: `a:example.com/24//64`
- [ ] Prefix edge cases: `a/0`, `a//0`

### 6.2 Evaluation Tests

- [ ] Simple pass: IP in `ip4` range
- [ ] Simple fail: IP not in range, ends `-all`
- [ ] Include pass: nested lookup passes
- [ ] Include fail: nested lookup fails
- [ ] Include propagation: child TempError → parent TempError
- [ ] Include propagation: child PermError → parent PermError
- [ ] Include: child None → no match (continue)
- [ ] MX mechanism: IP matches MX host
- [ ] A mechanism with CIDR
- [ ] PTR mechanism validation
- [ ] Redirect modifier
- [ ] Redirect to domain without SPF → PermError
- [ ] DNS lookup limit (11th lookup → PermError)
- [ ] Void lookup limit (3rd void → PermError)
- [ ] Circular include between 2 domains → PermError (via visited set, not just DNS limit)
- [ ] exp= explanation attached to Fail
- [ ] exp= failure → Fail without explanation (not crash)
- [ ] Empty MAIL FROM → postmaster@helo
- [ ] IPv6 client with ip6 mechanism
- [ ] IPv4 client skips ip6 mechanism
- [ ] exists mechanism with macro expansion

### 6.3 Macro Tests

- [ ] `%{s}` sender expansion
- [ ] `%{l}` local-part, `%{o}` domain
- [ ] `%{d}` current domain expansion
- [ ] `%{i}` IP expansion (v4 dotted, v6 dot-separated nibbles: 32 hex chars)
- [ ] `%{v}` → "in-addr" for v4, "ip6" for v6
- [ ] `%{h}` HELO domain
- [ ] `%{p}` → "unknown" (stub is acceptable)
- [ ] `%{ir}.origin.example.com` reversed IP
- [ ] `%{d2}` rightmost 2 labels, `%{d1r}` reversed first label
- [ ] `%{l-}` local-part with hyphen delimiter
- [ ] URL encoding with uppercase: `%{S}` URL-encodes sender
- [ ] Explanation-only macros `%{c}`, `%{r}`, `%{t}` in exp= context → succeed
- [ ] Reject `%{c}`, `%{r}`, `%{t}` outside exp= context → error
- [ ] Escapes: `%%` → `%`, `%_` → space, `%-` → `%20`
- [ ] `%{d0}` → entire domain (0 means all parts)

---

## 7. Security Considerations

- [ ] Prevent infinite loops in `include`/`redirect` via visited-domain HashSet
- [ ] Enforce DNS lookup limits strictly (max 10)
- [ ] Enforce void lookup limits (max 2)
- [ ] Validate all DNS responses — handle NxDomain vs empty vs error distinctly
- [ ] Don't trust PTR without forward confirmation
- [ ] DNS caching is caller's responsibility — document this clearly

---

## 8. Performance Considerations

- [ ] DNS caching: out of scope for library. Callers wrap the resolver.
- [ ] Short-circuit on first match (left-to-right, stop at first matching directive)
- [ ] Pre-compiled parsed records: `SpfRecord::parse` returns owned struct for reuse
- [ ] A/MX mechanism: query only the address family matching client IP (v4→A, v6→AAAA)

---

## 9. Implementation Learnings (from v1)

### 9.1 Async Recursion Pattern
- `check_host_inner` requires `Box::pin` for async recursion
- Signature: `fn check_host_inner<'a, R: DnsResolver>(...) -> Pin<Box<dyn Future<Output = SpfResult> + Send + 'a>>`
- Wrap body in `Box::pin(async move { ... })`

### 9.2 EvalContext as Shared Mutable State
- DNS lookup counter and void counter must be shared across include/redirect recursion
- Pass `&mut EvalContext` through recursive calls
- Counter incremented BEFORE the DNS query, not after — if limit exceeded, return PermError without querying

### 9.3 SPF Record Filtering
- TXT records may contain non-SPF data. Filter: lowercase starts with "v=spf1" followed by space or end-of-string
- `let lower = txt.to_ascii_lowercase(); lower == "v=spf1" || lower.starts_with("v=spf1 ")`

### 9.4 Void Lookup Tracking
- Void lookups: NxDomain responses during DNS-querying mechanisms
- Track separately from DNS lookup counter
- Also increment on NoRecords for A/AAAA queries in mechanism evaluation

### 9.5 MX Evaluation
- Sort MX records by preference before taking first 10
- DNS errors on individual MX host resolution: skip that host, don't fail entire mechanism

### 9.6 Gotchas
- `ip4`/`ip6` mechanisms: cross-family never matches (IPv6 client with ip4 → no match, not error)
- Empty expanded redirect domain → PermError (not None)
- Redirect target returning None → PermError (not None)
- Include child returning None → no match (not PermError — PermError is only for include-not-found at the include-child's level, but include child returning None means domain has no SPF, which maps to no-match in the parent)

---

## 10. Dependencies

- [ ] DNS resolver (async): `hickory-resolver` 0.25
- [ ] IP address handling: `std::net`
- [ ] CIDR matching: custom implementation (no external crate needed)

---

## Completion Checklist

- [ ] All data types defined with structured enums (not raw strings)
- [ ] Parser complete with all 8 mechanisms and 2 modifiers
- [ ] Macro expander complete with all letters, transformers, escapes
- [ ] `check_host()` algorithm implemented with recursive include/redirect
- [ ] DNS lookup limits enforced (10 DNS, 2 void)
- [ ] Circular include/redirect detection via visited-domain set
- [ ] exp= evaluation produces explanation on Fail
- [ ] All 7 result types returned correctly
- [ ] Unit tests cover parsing, evaluation, macros, limits, cycles
- [ ] No unwrap/expect in library code (tests only)
