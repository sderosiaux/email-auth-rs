# ARC Implementation Spec (RFC 8617)

> LLM-actionable specification for implementing Authenticated Received Chain

## Overview

ARC preserves email authentication results across intermediaries (mailing lists, forwarders) that modify messages and break DKIM signatures. It creates a chain of authentication snapshots that downstream receivers can evaluate.

**Scope**: Chain validation, chain sealing (adding new ARC sets), parsing all three ARC header types. Reuses DKIM canonicalization and crypto primitives from `src/dkim/`.

---

## 1. Data Types

### 1.1 ARC Set

An ARC Set = three headers sharing the same instance number (i=):

- [ ] `ArcAuthenticationResults` (AAR) — authentication snapshot on arrival
- [ ] `ArcMessageSignature` (AMS) — DKIM-like signature over message headers+body
- [ ] `ArcSeal` (AS) — signature over ARC headers only, seals the chain

```rust
struct ArcSet {
    instance: u32,  // 1..50
    aar: ArcAuthenticationResults,
    ams: ArcMessageSignature,
    seal: ArcSeal,
}
```

### 1.2 ARC-Authentication-Results (AAR)

- [ ] `instance: u32` — i= tag (required, 1-50)
- [ ] `payload: String` — RFC 8601 Authentication-Results content
- [ ] Format: `ARC-Authentication-Results: i=<N>; <authres-payload>`

### 1.3 ARC-Message-Signature (AMS)

- [ ] `instance: u32` — i= tag (required, NOT the DKIM AUID)
- [ ] `algorithm: Algorithm` — a= tag (rsa-sha256 primary)
- [ ] `signature: Vec<u8>` — b= tag (base64)
- [ ] `body_hash: Vec<u8>` — bh= tag (base64)
- [ ] `domain: String` — d= tag
- [ ] `selector: String` — s= tag
- [ ] `signed_headers: Vec<String>` — h= tag (colon-separated)
- [ ] `canonicalization: (CanonicalizationMethod, CanonicalizationMethod)` — c= tag
- [ ] `timestamp: Option<u64>` — t= tag
- [ ] `body_length: Option<u64>` — l= tag
- [ ] **NO v= tag** (unlike DKIM-Signature)
- [ ] h= MUST NOT include Authentication-Results or ARC-* headers
- [ ] h= MUST include existing DKIM-Signature headers — scan input headers and append `"dkim-signature"` to h= list once per occurrence. The filter that removes ARC-* headers keeps DKIM-Signature so `select_headers` can pick them up. <!-- forge:cycle-1 -->

### 1.4 ARC-Seal (AS)

- [ ] `instance: u32` — i= tag (required)
- [ ] `cv: ChainValidationStatus` — cv= tag (required: "none", "pass", "fail")
- [ ] `algorithm: Algorithm` — a= tag
- [ ] `signature: Vec<u8>` — b= tag (base64)
- [ ] `domain: String` — d= tag
- [ ] `selector: String` — s= tag
- [ ] `timestamp: Option<u64>` — t= tag
- [ ] **Allowed tags ONLY: i, cv, a, b, d, s, t**
- [ ] h= tag present → MUST fail validation
- [ ] **NO body hash** — AS does not cover message body
- [ ] **ONLY relaxed header canonicalization** — no body canonicalization

### 1.5 Chain Validation Status (cv=)

```rust
enum ChainValidationStatus {
    None,  // instance 1 MUST be "none"
    Pass,  // instance >1 MUST be "pass" (when sealing)
    Fail,  // chain validation failed
}
```

### 1.6 ARC Result

```rust
enum ArcResult {
    None,  // no ARC Sets present
    Pass,  // all validation steps passed
    Fail,  // any validation step failed
}

struct ArcValidationResult {
    status: ArcResult,
    oldest_pass: Option<u32>,  // lowest AMS instance that validated (0 if all pass)
}
```

---

## 2. Parsing

### 2.1 ARC Set Collection

- [ ] Collect all ARC-Authentication-Results, ARC-Message-Signature, ARC-Seal headers
- [ ] Group by instance number (i= tag)
- [ ] Each instance MUST have exactly one of each header type
- [ ] Maximum 50 ARC Sets (exceeding → Fail)
- [ ] Instance values MUST form continuous sequence 1..N (no gaps, no duplicates)

### 2.2 Tag Parsing

- [ ] AMS: same tag=value format as DKIM-Signature (reuse `parse_tags`)
- [ ] AS: same tag=value format but restricted tag set
- [ ] AAR: `i=<N>; <authres-payload>` — parse instance, rest is opaque

### 2.3 Required Tags

- [ ] AMS required: i, a, b, bh, d, s, h
- [ ] AMS optional: c, t, l
- [ ] AS required: i, cv, a, b, d, s
- [ ] AS optional: t
- [ ] AAR required: i

### 2.4 Parse Errors → Fail

- [ ] Missing required tag
- [ ] Duplicate tag
- [ ] Instance number outside 1-50
- [ ] Malformed base64 (b=, bh=)
- [ ] Unknown algorithm
- [ ] AS header with h= tag present
- [ ] Multiple headers with same instance and type
- [ ] Instance gaps (e.g., 1, 2, 4 — missing 3)

---

## 3. Chain Validation Algorithm (RFC 8617 Section 5.2)

Execute in sequence:

### Step 1: Collect ARC Sets

- [ ] If none exist → status="none", STOP
- [ ] If >50 sets → status="fail", STOP
- [ ] Let N = highest instance value

### Step 2: Check Latest cv Value

- [ ] If AS(N) has cv=fail → status="fail", STOP

### Step 3: Validate Structure

- [ ] Each ARC Set has exactly one AAR, AMS, AS
- [ ] Instances form continuous 1..N
- [ ] Instance 1: cv=none
- [ ] Instance >1: cv=pass (not "fail" or "none")
- [ ] Any violation → status="fail", STOP

### Step 4: Validate Most Recent AMS

- [ ] Validate AMS(N) using DKIM verification algorithm (RFC 6376 Section 5)
- [ ] DNS key lookup at `<selector>._domainkey.<domain>`
- [ ] If fails → status="fail", STOP

### Step 5 (OPTIONAL): Determine oldest-pass

- [ ] From instance N-1 down to 1: validate each AMS
- [ ] If instance M fails → oldest-pass = M+1, go to Step 6
- [ ] If all pass → oldest-pass = 0

### Step 6: Validate All AS Headers

- [ ] From instance N down to 1: validate each AS
- [ ] Build signature input: all ARC headers from instance 1 to i, in order (AAR, AMS, AS per set)
- [ ] Strip b= from AS being validated
- [ ] Use **relaxed header canonicalization only**
- [ ] If any fails → status="fail", STOP

### Step 7: Success

- [ ] status="pass"

---

## 4. ARC-Seal Signature Input

For AS at instance i:

- [ ] Include ARC Sets 1 through i in increasing order
- [ ] Within each set, header order: AAR → AMS → AS
- [ ] Apply relaxed header canonicalization to each
- [ ] Strip b= value from the AS being validated/signed (same b= stripping as DKIM)
- [ ] **NO body content** in AS signature input
- [ ] Last header (the AS being validated) WITHOUT trailing CRLF

---

## 5. Chain Sealing Algorithm (RFC 8617 Section 5.1)

### Step 1: Complete All Modifications First

- [ ] Perform ALL message modifications (including DKIM signing) BEFORE sealing
- [ ] ARC sealing is the LAST operation

### Step 2: Check Incoming Chain

- [ ] If existing chain has highest AS with cv=fail → STOP, do NOT seal

### Step 3: Calculate Instance

- [ ] If chain exists: instance = max_existing + 1
- [ ] If no chain: instance = 1
- [ ] If instance > 50 → STOP, do NOT seal

### Step 4: Determine cv Value

- [ ] Validate incoming chain
- [ ] No chain → cv=none
- [ ] Validation passed → cv=pass
- [ ] Validation failed → cv=fail (but Step 2 should have stopped)

### Step 5: Generate AAR

- [ ] `ARC-Authentication-Results: i=<N>; <authservid>; <results>`
- [ ] Include ALL authentication results from this ADMD (SPF, DKIM, DMARC, ARC)

### Step 6: Generate AMS

- [ ] Compute body hash (same as DKIM)
- [ ] Select headers for h= tag:
  - MUST include existing DKIM-Signature headers
  - MUST NOT include Authentication-Results or ARC-* headers
  - SHOULD include From, To, Subject, Date, Message-ID
- [ ] Sign using DKIM algorithm
- [ ] Format: `ARC-Message-Signature: i=<N>; a=rsa-sha256; c=relaxed/relaxed; d=<d>; s=<s>; h=<h>; bh=<bh>; b=<b>`

### Step 7: Generate AS

- [ ] Build signature input: ALL ARC Sets (1..N) in order (AAR, AMS, AS per set)
- [ ] Strip b= from this AS
- [ ] **Relaxed header canonicalization only**
- [ ] Sign
- [ ] Format: `ARC-Seal: i=<N>; cv=<cv>; a=rsa-sha256; d=<d>; s=<s>; b=<b>`

### Step 8: Attach Headers

- [ ] Add AAR, AMS, AS to message
- [ ] Added at message exit (after all processing)

---

## 6. API Design

```rust
pub struct ArcVerifier<R: DnsResolver> {
    resolver: R,
}

impl<R: DnsResolver> ArcVerifier<R> {
    pub async fn validate_chain(
        &self,
        headers: &[(&str, &str)],
        body: &[u8],
    ) -> ArcValidationResult;
}

pub struct ArcSealer {
    domain: String,
    selector: String,
    private_key: PrivateKey,
}

impl ArcSealer {
    pub async fn seal_message<R: DnsResolver>(  // async — validates incoming chain via verifier <!-- forge:cycle-1 -->
        &self,
        verifier: &ArcVerifier<R>,
        headers: &[(&str, &str)],
        body: &[u8],
        authres_payload: &str,
    ) -> Result<(String, String, String), SealError>;
    // Returns (AAR header value, AMS header value, AS header value)
}
```

---

## 7. Relationship to DKIM

AMS is a DKIM signature with:
- Instance tag (i=) instead of AUID
- No version tag (v=)
- Restricted h= (no Auth-Results, no ARC-* headers)
- Reuse: canonicalization, body hash, signing, verification, key lookup

AS is DKIM-derived but:
- No body hash (bh=)
- Only relaxed header canonicalization
- cv= tag added
- Limited tag set (no h=, no l=, no c=)
- Covers ARC headers only

**Code reuse from DKIM module:**
- `canon::canonicalize_header()` — relaxed header canonicalization
- `canon::canonicalize_body()` — for AMS body hash
- `canon::strip_b_tag()` — for AS b= stripping
- `canon::select_headers()` — for AMS header selection
- `key.rs` — DNS key record parsing (same format)
- `verify.rs` — crypto verification logic (same ring API)
- `sign.rs` — crypto signing logic

---

## 8. Test Cases

### 8.1 Parsing

- [ ] Valid AAR with instance 1
- [ ] Valid AMS with all required tags
- [ ] Valid AS with cv=none, cv=pass, cv=fail
- [ ] AS with h= tag → Fail
- [ ] Missing required tag → Fail
- [ ] Instance 0 or 51 → Fail
- [ ] Duplicate tags → Fail

### 8.2 Chain Validation

- [ ] Single ARC Set (i=1, cv=none) → Pass
- [ ] Three sets (i=1,2,3; cv=none,pass,pass) → Pass
- [ ] Gap in instances (1,2,4) → Fail
- [ ] Duplicate instances → Fail
- [ ] Instance 1 with cv=pass → Fail
- [ ] Instance 2 with cv=none → Fail
- [ ] Highest instance cv=fail → Fail immediately
- [ ] >50 sets → Fail
- [ ] Most recent AMS fails → Fail
- [ ] Any AS fails → Fail

### 8.3 Sealing

- [ ] Seal with no existing chain → i=1, cv=none
- [ ] Seal with valid chain (i=2) → i=3, cv=pass
- [ ] Incoming cv=fail → do not seal
- [ ] Instance would exceed 50 → do not seal
- [ ] Verify AS covers all prior ARC Sets

### 8.4 Roundtrip (MUST use full pipeline, not manual crypto)

- [ ] Seal → validate → Pass: `ArcSealer::seal_message()` produces AAR/AMS/AS → prepend to message headers → `ArcVerifier::validate_chain()` returns Pass. **MUST NOT substitute manual ring verification** — the purpose is to test that sealer and verifier agree.
- [ ] Seal → modify body → validate AMS fails
- [ ] Seal → tamper ARC header → validate AS fails
- [ ] Multi-hop: 3 sealers each adding ARC set, final `ArcVerifier::validate_chain()` returns Pass with all 3 sets
- [ ] Multi-hop body modification: sealer 1 signs, intermediary modifies body, sealer 2 re-signs → validate_chain returns Pass for set 2 AMS but oldest_pass > 1

---

## 9. Security Considerations

- [ ] Up to 2*N DNS queries for N sets — implement timeouts
- [ ] ARC conveys authentication assessment, NOT authorization — receivers must maintain trusted sealer lists
- [ ] cv=fail propagates — once failed, subsequent handlers should not seal with cv=pass
- [ ] Replay: intact ARC chains can be replayed; ARC does not prevent this

---

## 10. Dependencies

- [ ] DKIM module (canonicalization, signing, verification, key parsing)
- [ ] DNS resolver (shared DnsResolver trait)
- [ ] Crypto: ring 0.17 (RSA-SHA256, same as DKIM)
- [ ] Base64: base64 0.22

---

## 11. Implementation Learnings

### 11.1 DKIM Code Reuse
- AMS verification reuses DKIM verification almost entirely — `verify_signature()` extracted as shared function
- AS verification is similar but WITHOUT body hash, only relaxed header canon, and different header selection (ARC headers only)
- Key lookup identical: `<selector>._domainkey.<domain>` TXT record
- Canonicalization functions reused directly from `dkim::canon`

### 11.2 ARC Header Ordering
- ARC Sets MUST be processed in ascending instance order (1, 2, 3, ...)
- Within each set, header order for AS signature input: AAR → AMS → AS
- The AS being validated/signed is LAST, with b= stripped, WITHOUT trailing CRLF

### 11.3 Seal API Design
- `ArcSealer::seal_message()` is **async** — takes `&ArcVerifier<R>` to validate incoming chain for cv= determination <!-- forge:cycle-1 -->
- Returns 3 header values (AAR, AMS, AS) — caller prepends header names
- Sealer generates AMS using DKIM signing primitives, then AS over all ARC headers

### 11.3b ArcSealer as Independent Type <!-- forge:cycle-1 -->
- ArcSealer holds its own `PrivateKey` — does NOT wrap DkimSigner
- ARC sealing has different requirements: always relaxed/relaxed, no v= tag, instance-based, cv= tag
- Code duplication: `wrap_pkcs1_in_spki()`, `decode_pem()`, `encode_asn1_length()` are duplicated between dkim/sign.rs and arc/seal.rs
- Could extract to `common::crypto` module — not worth it unless a third consumer appears

### 11.3c AMS Header Selection <!-- forge:cycle-1 -->
- AMS validation filters ALL ARC-* headers from the header set before `select_headers()` — AMS signs only original message headers
- DKIM-Signature headers are KEPT (not filtered) — AMS should sign them
- When sealing: `seal_message` counts DKIM-Signature headers in input and appends `"dkim-signature"` to h= list once per occurrence

### 11.3d Multi-Hop Test Pattern <!-- forge:cycle-1 -->
- Multi-hop tests building iterative chain signatures must track raw headers in stable order via `ordered_sets: Vec<(aar, ams, seal)>`
- Using `insert(0, ...)` (prepend) to build `arc_headers` shifts previous indices on each hop — maintain separate ordered data structure
- `subtle::ConstantTimeEq`: `ct_eq().into()` may fail type inference — use `bool::from(ct_eq())`

### 11.4 v3 Bugs and Gaps

#### 11.4.1 AMS h= Restriction Not Enforced
- RFC 8617 §5.1 says AMS h= MUST NOT include Authentication-Results or ARC-* headers
- v3 parsing accepted any headers in h= without validation
- **FIX**: During AMS parsing, check h= entries and reject if any match `arc-authentication-results`, `arc-message-signature`, `arc-seal`, or `authentication-results` (case-insensitive)

#### 11.4.2 Multi-Hop Testing
- v3 tested single-hop seal→validate and basic multi-hop (3 sealers)
- Missing: test where intermediate hop modifies body (AMS body hash should fail for earlier sets but pass for latest)
- Missing: test where intermediate hop adds headers that break earlier DKIM but ARC chain remains valid

#### 11.4.3 Patterns That Worked
- Grouping ARC headers by instance into `ArcSet` struct — clean validation
- Continuous instance sequence validation as separate step — catches gaps early
- Reusing DKIM `strip_b_tag()` for AS b= stripping — no duplication

---

## Completion Checklist

- [ ] All three ARC header types parsed (AAR, AMS, AS)
- [ ] ARC Set grouping by instance with structure validation
- [ ] Chain validation algorithm (steps 1-7) complete
- [ ] AMS validation reuses DKIM verification
- [ ] AS validation with correct signature input ordering
- [ ] Chain sealing (AAR + AMS + AS generation)
- [ ] Seal uses DKIM signing primitives
- [ ] cv= propagation rules enforced
- [ ] Instance limit (50) enforced
- [ ] Unit tests cover parsing, validation, sealing, roundtrip
