# SPF Implementation Spec (RFC 7208)

> LLM-actionable specification for implementing Sender Policy Framework

## Overview

SPF allows domain owners to publish DNS TXT records declaring which mail servers are authorized to send email on their behalf. Receiving servers query these records and evaluate sender IP against the policy.

---

## 1. Data Types

### 1.1 SPF Record Structure

- [ ] Define `SpfRecord` struct containing:
  - [ ] `version: SpfVersion` (must be "v=spf1")
  - [ ] `directives: Vec<Directive>` (mechanisms with qualifiers)
  - [ ] `modifiers: Vec<Modifier>` (redirect, exp)
  - [ ] `raw: String` (original record for debugging)

### 1.2 Directive (Mechanism + Qualifier)

- [ ] Define `Directive` struct:
  - [ ] `qualifier: Qualifier` (enum: Pass `+`, Fail `-`, SoftFail `~`, Neutral `?`)
  - [ ] `mechanism: Mechanism`

### 1.3 Mechanisms

- [ ] Define `Mechanism` enum with variants:
  - [ ] `All` — matches everything
  - [ ] `Include { domain: String }` — recursive lookup
  - [ ] `A { domain: Option<String>, cidr4: Option<u8>, cidr6: Option<u8> }` — A/AAAA records
  - [ ] `Mx { domain: Option<String>, cidr4: Option<u8>, cidr6: Option<u8> }` — MX records
  - [ ] `Ptr { domain: Option<String> }` — PTR record (deprecated but must support)
  - [ ] `Ip4 { addr: Ipv4Addr, prefix: Option<u8> }` — IPv4 CIDR
  - [ ] `Ip6 { addr: Ipv6Addr, prefix: Option<u8> }` — IPv6 CIDR
  - [ ] `Exists { domain: String }` — DNS existence check

### 1.4 Modifiers

- [ ] Define `Modifier` enum:
  - [ ] `Redirect { domain: String }` — use another domain's policy
  - [ ] `Exp { domain: String }` — explanation string for failures

### 1.5 Result Types

- [ ] Define `SpfResult` enum (RFC 7208 Section 2.6):
  - [ ] `Pass` — sender is authorized
  - [ ] `Fail` — sender is NOT authorized
  - [ ] `SoftFail` — weak authorization failure
  - [ ] `Neutral` — no assertion made
  - [ ] `None` — no SPF record found
  - [ ] `TempError` — transient DNS error
  - [ ] `PermError` — permanent error (syntax, etc.)

### 1.6 Check Context

- [ ] Define `SpfContext` struct for `check_host()`:
  - [ ] `client_ip: IpAddr` — connecting server IP
  - [ ] `helo_domain: String` — HELO/EHLO identity
  - [ ] `mail_from: String` — MAIL FROM identity (envelope sender)
  - [ ] `receiver: String` — receiving domain (for macros)

---

## 2. Record Parsing (RFC 7208 Section 12)

### 2.1 TXT Record Retrieval

- [ ] Query DNS TXT records for domain
- [ ] Filter records starting with "v=spf1" (may have trailing space or be end of record)
- [ ] Handle multiple TXT records: must be exactly one SPF record, else `PermError`
- [ ] Handle no SPF record: return `None`

### 2.2 Record Grammar (ABNF from RFC 7208)

- [ ] Parse version: `"v=spf1"` (case-insensitive)
- [ ] Parse directives: `[qualifier] mechanism`
- [ ] Default qualifier is `+` (Pass) if omitted
- [ ] Parse modifiers: `name=value` (only `redirect` and `exp` defined)
- [ ] Handle unknown mechanisms: `PermError`
- [ ] Handle unknown modifiers: ignore (forward compatibility)

### 2.3 Mechanism Argument Parsing

- [ ] `all` — no arguments
- [ ] `include:<domain>` — domain spec required
- [ ] `a` / `a:<domain>` / `a:<domain>/<cidr4>` / `a:<domain>//<cidr6>` / `a:<domain>/<cidr4>//<cidr6>`
- [ ] `mx` — same argument patterns as `a`
- [ ] `ptr` / `ptr:<domain>` — optional domain
- [ ] `ip4:<ip4-network>` — address with optional `/prefix` (default /32)
- [ ] `ip6:<ip6-network>` — address with optional `/prefix` (default /128)
- [ ] `exists:<domain>` — domain spec with macros

### 2.4 Macro Expansion (RFC 7208 Section 7)

- [ ] Implement macro expander for domain-spec strings
- [ ] Macro letters (case determines URL encoding):
  - [ ] `s` — sender (local-part@domain or postmaster@domain)
  - [ ] `l` — local-part of sender
  - [ ] `o` — domain of sender
  - [ ] `d` — current domain being evaluated
  - [ ] `i` — client IP (dotted for v4, dot-separated nibbles for v6 e.g., `1.0.0.0.0.0.0.0...`)
  - [ ] `p` — validated domain name of client IP (PTR)
  - [ ] `v` — IP version string ("in-addr" or "ip6")
  - [ ] `h` — HELO/EHLO domain
- [ ] Explanation-only macro letters (only valid in `exp=` TXT expansion):
  - [ ] `c` — SMTP client IP in readable format
  - [ ] `r` — receiving MTA domain name
  - [ ] `t` — current Unix timestamp
- [ ] Delimiter transformers: `{<letter><digits>r<delimiters>}`
  - [ ] Digits: take rightmost N parts
  - [ ] `r`: reverse order
  - [ ] Delimiters: split characters (default ".")
- [ ] URL-encode if uppercase macro letter
- [ ] Handle `%%` (literal %), `%_` (space), `%-` (URL-encoded space)

---

## 3. Evaluation Algorithm: `check_host()` (RFC 7208 Section 4)

### 3.1 Input Validation

- [ ] Validate `client_ip` is well-formed
- [ ] Validate `domain` is valid DNS name
- [ ] Handle empty MAIL FROM: use `postmaster@<helo_domain>`

### 3.2 DNS Lookup Limits (RFC 7208 Section 4.6.4)

- [ ] Track DNS lookup count across evaluation
- [ ] Limit: max 10 DNS lookups (A, MX, PTR, include, redirect, exists)
- [ ] `ip4`, `ip6`, `all` do NOT count toward limit
- [ ] Exceeding limit → `PermError`
- [ ] Track void lookups (NXDOMAIN/empty): recommended max 2 void lookups → `PermError`
- [ ] Evaluation time limit: recommended minimum 20 seconds before timeout

### 3.3 Mechanism Evaluation Order

- [ ] Evaluate directives left-to-right
- [ ] First match determines result (qualifier → result mapping)
- [ ] If no match and no `redirect`: use `Neutral`
- [ ] If `redirect` modifier present: evaluate target domain instead

### 3.4 Individual Mechanism Evaluation

#### `all`
- [ ] Always matches
- [ ] Typically last directive (e.g., `-all`, `~all`)

#### `include:<domain>`
- [ ] Recursively call `check_host()` with new domain
- [ ] Map child results:
  - [ ] `Pass` → match (use parent qualifier)
  - [ ] `Fail`, `SoftFail`, `Neutral`, `None` → no match
  - [ ] `TempError` → `TempError`
  - [ ] `PermError` → `PermError`
- [ ] Increment DNS lookup counter

#### `a` / `a:<domain>`
- [ ] Expand macros in domain (default: current domain)
- [ ] Query A records (if client is IPv4) or AAAA (if IPv6)
- [ ] Apply CIDR mask (default /32 for v4, /128 for v6)
- [ ] Match if client IP within any returned network
- [ ] Increment DNS lookup counter

#### `mx` / `mx:<domain>`
- [ ] Expand macros in domain
- [ ] Query MX records, then A/AAAA for each MX host
- [ ] Limit: first 10 MX records only
- [ ] Apply CIDR mask, match if client IP within any
- [ ] Increment DNS lookup counter per MX query

#### `ptr` / `ptr:<domain>` (deprecated)
- [ ] Reverse lookup client IP → hostnames
- [ ] For each hostname: forward lookup → IPs
- [ ] Confirm client IP in forward results (validated hostname)
- [ ] Match if validated hostname ends with target domain
- [ ] Increment DNS lookup counter
- [ ] Note: Limit PTR results to 10

#### `ip4:<network>`
- [ ] Parse IPv4 address and optional prefix
- [ ] Match if client IPv4 within CIDR range
- [ ] No DNS lookup

#### `ip6:<network>`
- [ ] Parse IPv6 address and optional prefix
- [ ] Match if client IPv6 within CIDR range
- [ ] No DNS lookup

#### `exists:<domain>`
- [ ] Expand macros in domain
- [ ] Query A record (any result = match, NXDOMAIN = no match)
- [ ] Increment DNS lookup counter

### 3.5 Modifier Processing

#### `redirect=<domain>`
- [ ] Only processed if no directive matched
- [ ] Expand macros, then `check_host()` on target
- [ ] Target `None` → `PermError`
- [ ] Increment DNS lookup counter

#### `exp=<domain>`
- [ ] Only used when result is `Fail`
- [ ] Query TXT record at expanded domain
- [ ] Expand macros in TXT result → explanation string
- [ ] Store in result for optional use

---

## 4. DNS Interface Requirements

- [ ] Abstract DNS resolver trait for testability
- [ ] Support async DNS queries
- [ ] Methods needed:
  - [ ] `query_txt(domain) -> Result<Vec<String>, DnsError>`
  - [ ] `query_a(domain) -> Result<Vec<Ipv4Addr>, DnsError>`
  - [ ] `query_aaaa(domain) -> Result<Vec<Ipv6Addr>, DnsError>`
  - [ ] `query_mx(domain) -> Result<Vec<(u16, String)>, DnsError>`
  - [ ] `query_ptr(ip) -> Result<Vec<String>, DnsError>`
- [ ] Handle DNS timeouts → `TempError`
- [ ] Handle NXDOMAIN vs empty response
- [ ] Handle SERVFAIL → `TempError`

---

## 5. Error Handling

- [ ] `PermError` conditions:
  - [ ] Multiple SPF records
  - [ ] Syntax errors in record
  - [ ] Unknown mechanism
  - [ ] DNS lookup limit exceeded
  - [ ] Void lookup limit exceeded
  - [ ] `redirect` to domain with no SPF
  - [ ] Circular `include` (detect loops)
- [ ] `TempError` conditions:
  - [ ] DNS timeout
  - [ ] DNS SERVFAIL
  - [ ] Transient network errors

---

## 6. API Design

### 6.1 Public Functions

- [ ] `SpfRecord::parse(txt: &str) -> Result<SpfRecord, ParseError>`
- [ ] `check_host(ctx: &SpfContext, domain: &str, resolver: &dyn Resolver) -> SpfResult`
- [ ] `check_host_async(ctx: &SpfContext, domain: &str, resolver: &dyn AsyncResolver) -> impl Future<Output = SpfResult>`

### 6.2 Builder Pattern for Context

- [ ] `SpfContext::builder()`
- [ ] `.client_ip(ip)`
- [ ] `.mail_from(sender)`
- [ ] `.helo(domain)`
- [ ] `.receiver(domain)`
- [ ] `.build()`

---

## 7. Test Cases

### 7.1 Parsing Tests

- [ ] Valid minimal: `v=spf1 -all`
- [ ] Multiple mechanisms: `v=spf1 ip4:192.0.2.0/24 ip4:198.51.100.0/24 -all`
- [ ] Include: `v=spf1 include:_spf.google.com -all`
- [ ] All mechanism types
- [ ] Macros in domain specs
- [ ] Case insensitivity: `V=SPF1 IP4:...`
- [ ] Invalid version: `v=spf2` → error
- [ ] Duplicate modifiers: `redirect=a redirect=b` → error
- [ ] Unknown modifier: `foo=bar` → ignore

### 7.2 Evaluation Tests

- [ ] Simple pass: IP in `ip4` range
- [ ] Simple fail: IP not in range, ends `-all`
- [ ] Include pass: nested lookup passes
- [ ] Include fail: nested lookup fails
- [ ] MX mechanism: IP matches MX host
- [ ] A mechanism with CIDR
- [ ] PTR mechanism (deprecated path)
- [ ] Redirect modifier
- [ ] DNS lookup limit (10)
- [ ] Void lookup limit (2)

### 7.3 Macro Tests

- [ ] `%{s}` sender expansion
- [ ] `%{d}` domain expansion
- [ ] `%{i}` IP expansion (v4 dotted, v6 dotted-hex)
- [ ] `%{ir}.origin.example.com` reversed IP
- [ ] `%{l1r+}` local-part with delimiter
- [ ] URL encoding with uppercase
- [ ] Explanation-only macros `%{c}`, `%{r}`, `%{t}` in exp= context
- [ ] Reject `%{c}`, `%{r}`, `%{t}` outside exp= context

### 7.4 Real-World Records

- [ ] Google: `v=spf1 include:_spf.google.com ~all`
- [ ] Microsoft: complex include chain
- [ ] Multiple IP ranges

---

## 8. Security Considerations

- [ ] Prevent infinite loops in `include`/`redirect`
- [ ] Enforce DNS lookup limits strictly
- [ ] Validate all DNS responses
- [ ] Don't trust PTR without forward confirmation
- [ ] Rate limit DNS queries if needed
- [ ] Log evaluation path for debugging

---

## 9. Performance Considerations

- [ ] Cache DNS results (respect TTL)
- [ ] Parallel DNS queries where possible (A + AAAA)
- [ ] Short-circuit on first match
- [ ] Pre-compile parsed records for repeated use

---

## 10. Dependencies

- [ ] DNS resolver (async): `hickory-dns` or `trust-dns`
- [ ] IP address handling: `std::net`
- [ ] CIDR matching: custom or `ipnet` crate

---

## Completion Checklist

- [ ] All data types defined
- [ ] Parser complete with all mechanisms
- [ ] Macro expander complete
- [ ] `check_host()` algorithm implemented
- [ ] DNS lookup limits enforced
- [ ] All result types returned correctly
- [ ] Unit tests passing
- [ ] Integration tests with real DNS
- [ ] Documentation complete
